#!/usr/bin/env perl
# Name:           read_mongodb_genome.pl
# Description:    Annotates a given snpfile using binary indexed genome data generated by 'create_binary_genome_index.pl'.
#                 Input:  snpfile
#                 Output: tab-delim annotation, json annotation, tab-delim summary statistics for ids in snpfile,
#                         json summary statistics for ids in snpfile
#
# Date Created:   Tue Sep 21 13:36:45 2014
# Date Modified:  Tue Sep 21 13:26:45 2014
# By:             TS Wingo

use lib '/Users/twingo/software/Seq/lib';
use autodie;
use Cpanel::JSON::XS;
use Fcntl qw(:DEFAULT :seek);
use File::Spec;
use IO::File;
use Getopt::Long;
use Modern::Perl qw(2013);
use Pod::Usage;
use Snpfile::Tools;
use YAML::XS qw( LoadFile );
use Seq::GenomeSizedTrackChar;
use DDP;

my $hg38_config_file = "/Users/twingo/software/Seq/t/hg38_build_test.yml";

my @exts              = qw(snp);
my @var_types         = qw(DEL INS SNP MESS);
my @var_type_codes    = qw(Silent Replacement Intronic Intergenic);
my @header_snpfile    = qw(Fragment Position Reference Minor_allele Type);
my @header_basefile   = qw(Fragment Position Reference);
my @header_annotation = qw(base raw_genome_dat
                           genomic_annotation_code
                           gene_annotation_code
                           alt_name transcript_id
                           org_codon aa snp_id maf);
my (%in_fhs, %bin_fhs);
my ($chr_len_ref, $bin_codes_ref, $genome_bin_seq, $genome_dat_buffer, $idx_codes_ref);
my ($chr_wanted, $pos_from, $pos_to, $db_location, $db_name, $verbose);
my (%idx_2_base, %idx_2_snp, %idx_2_in_exon, %idx_2_annotated, %idx_2_in_gene);
my ($client, $db, $gan_db, $snp_db, $dbsnp_name, $dbgene_name);

#
# usage
#
die "usage --from <pos> --to <pos> --db_name <hg38> --l <.>"
  unless GetOptions(
                    'c|chr=s'      => \$chr_wanted,
                    'f|from=n'     => \$pos_from,
                    't|to=n'       => \$pos_to,
                    'n|db_name=s'  => \$db_name,
                    'l|location=s' => \$db_location,
                    'v|verbose'    => \$verbose,
                   )
  and defined $pos_from
  and defined $pos_to
  and defined $db_name
  and defined $db_location;

#
# process input preferences and load Mongodb collections
#

#
# clean up position
#
$pos_from =~ s/\_|\,//g;
$pos_to =~ s/\_|\,//g;

#
# sanity check position
#
if ($pos_from >= $pos_to)
{
  say "from_position ('$pos_from') needs to be smaller than to_position ('$pos_to')\n";
  exit;
}

  #
  #  open binary files
  #   idx - binary representation of every base in the genome
  #
  $db_location = File::Spec->canonpath( $db_location );
  my $db_file  = File::Spec->catfile( $db_location, "$db_name.genome.idx" );
  my $idx_fh   = new IO::File->new( $db_file, 'r' )
    or die "cannot open $db_file";
  binmode $idx_fh;
  my $genome_chr_seq;
  read $idx_fh, $genome_chr_seq, -s $db_file;
  my $yaml_file = File::Spec->catfile( $db_location, "$db_name.genome.chr_len" );
  my $chr_len_href = LoadFile( $yaml_file );
  p $chr_len_href;


# obj creation
my $hg38_dat = LoadFile( $hg38_config_file );
my (%hg38_genome_config, %chr_lens);

for my $attr_href ( @{ $hg38_dat->{genome_sized_tracks} } )
{
  if ($attr_href->{type} eq "genome")
  {
    for my $attr ( keys %{ $attr_href })
    {
      $hg38_genome_config{ $attr } = $attr_href->{$attr};
    }
  }
}
$hg38_genome_config{genome_chrs} = $hg38_dat->{genome_chrs};
$hg38_genome_config{genome_length} =  -s $db_file;
$hg38_genome_config{char_seq} = \$genome_chr_seq;
$hg38_genome_config{chr_len} = $chr_len_href;

my $gct = Seq::GenomeSizedTrackChar->new( \%hg38_genome_config );
my @seq;

for (my $i = $pos_from; $i < $pos_to; $i++)
{
  my $zero_idx = $i;
  my $one_idx  = $i + 1;

  my $base_code = $gct->get_base( $zero_idx  );
  my $chr = get_chr( $zero_idx  );
  my $rel_pos = $i + 1 - $gct->get_abs_pos( $chr, 1 );

  my $base = $gct->get_idx_base( $base_code );
  my $gan  = ($gct->get_idx_in_gan( $base_code )) ? 1 : 0;
  my $gene = ($gct->get_idx_in_gene( $base_code )) ? 1 : 0;
  my $exon = ($gct->get_idx_in_exon( $base_code )) ? 1 : 0;
  my $snp  = ($gct->get_idx_in_snp( $base_code )) ? 1 : 0;


  say join ("\t", $i, $chr, $rel_pos, $base_code, $base, $gan, $gene, $exon, $snp );
  push @seq, $base;
}

Print_fa (\@seq);

sub Print_fa {
  my $seq_aref = shift;

  for (my $i = 0; $i < @{ $seq_aref }; $i++)
  {
    print "\n" if ($i % 80 == 0);
    print $seq_aref->[$i];
  }
}

sub get_chr {
  my $pos = shift;
  my @chrs = map { "chr" . $_ } (1..22, 'M', 'X', 'Y');
  for my $i (0 .. scalar @chrs)
  {
    my $chr = $chrs[$i];
    my $chr_len = $gct->get_abs_pos( $chr, 1 );
    my $next_chr = $chrs[$i+1];
    my $next_chr_len = $gct->get_abs_pos( $next_chr, 1 );

    #say "$pos < $next_chr_len && $pos >= $chr_len";

    if ($pos < $next_chr_len && $pos >= $chr_len)
    {
      return $chr;
    }
  }
}


__END__

  #
  # read json files
  #
  {
    #
    # read chr lengths
    #
    my $json = Cpanel::JSON::XS->new();

    open(my $in_len, '<:raw', "$db_location/$db_name.len.json");
    local $/;
    my $json_len = <$in_len>;
    $chr_len_ref = decode_json($json_len);
    print $json->pretty(1)->encode($chr_len_ref);

    #
    # read typedefs and lengths
    #
    open(my $in_type, '<:raw', "$db_location/$db_name.type.json");
    my $json_type = <$in_type>;
    $bin_codes_ref = decode_json($json_type);
    print $json->pretty(1)->encode($bin_codes_ref);

    #
    # read idx codes
    #
    open (my $in_idx_codes, '<:raw', "$db_location/$db_name.idx_codes.json");
    my $json_idx_codes = <$in_idx_codes>;
    $idx_codes_ref = decode_json($json_idx_codes);
    print $json->pretty(1)->encode($idx_codes_ref);

    #
    # make hashes for
    #   1) base
    #   2) annoated
    #   3) in_gene
    #   4) exon
    #   5) snp
    #
    foreach my $base (sort keys %{ $idx_codes_ref })
    {
      foreach my $annotated (sort keys %{$idx_codes_ref->{$base}}) # do we lookup annotation
      {
        foreach my $in_gene (sort keys %{$idx_codes_ref->{$base}{$annotated}}) # intronic or exonic vs intergenic
        {
          foreach my $exon (sort keys %{$idx_codes_ref->{$base}{$annotated}{$in_gene}}) # intronic vs exonic
          {
            foreach my $snp (sort keys %{$idx_codes_ref->{$base}{$annotated}{$in_gene}{$exon}}) # do we lookup snp
            {
              my $code = $idx_codes_ref->{$base}{$annotated}{$in_gene}{$exon}{$snp};
              $idx_2_base{$code} = $base;
              if ($annotated)
              {
                $idx_2_annotated{$code} = $base;
              }
              if ($in_gene)
              {
                $idx_2_in_gene{$code} = $base;
              }
              if ($exon)
              {
                $idx_2_in_exon{$code} = $base;
              }
              if ($snp)
              {
                $idx_2_snp{$code} = $base;
              }
            }
          }
        }
      }
    }
  }
  #
  # exit if the chromosome that is wanted is not one of the chromosomes read
  #
  if (!exists($chr_len_ref->{$chr_wanted}))
  {
    say "the chromosome you supplied: $chr_wanted was not listed in the binary index";
  }
}

#
# read genome
#
{
  $bin_fhs{'idx'}->read($genome_dat_buffer, $chr_len_ref->{'genome'});
  say "finished reading genome";
}

for (my $i = $pos_from ; $i <= $pos_to ; $i++)
{
  my $json    = Cpanel::JSON::XS->new() if $verbose;
  my $abs_pos = $chr_len_ref->{$chr_wanted} + $i;
  my (%records, @gan_results, @snp_results, $gan_qres, $snp_qres) = ( );
  my ($base_code, $base, $annotated, $in_gene_code, $in_exon, $snp_code) = (0, 0, 0, 0, 0, 0);

  #
  # decode base
  #
  $base_code    = unpack($bin_codes_ref->{'typedef'}{'idx'}, (substr($genome_dat_buffer, ($abs_pos - 1), 1)));
  unless (defined $base_code) { die "$base_code - error extracing $chr_wanted:$i ($abs_pos) from genome - ensure you are within range";}
  $base         = $idx_2_base{$base_code}      if (exists($idx_2_base{$base_code}));
  $annotated    = $idx_2_annotated{$base_code} if (exists($idx_2_annotated{$base_code}));
  $in_gene_code = $idx_2_in_gene{$base_code}   if (exists($idx_2_in_gene{$base_code}));
  $in_exon      = $idx_2_in_exon{$base_code}   if (exists($idx_2_in_exon{$base_code}));
  $snp_code     = $idx_2_snp{$base_code}       if (exists($idx_2_snp{$base_code}));

  $records{'base'} = $base;
  $records{'raw_genome_dat'} = join("\t", $base_code, $base, $annotated, $in_gene_code, $in_exon, $snp_code);

  if ($in_gene_code)
  {
    if ($in_exon)
    {
      $records{'genomic_annotation_code'} = "Exonic";
    }
    else
    {
      $records{'genomic_annotation_code'} = "Introinc";
    }
  }
  else
  {
    $records{'genomic_annotation_code'} = "Intergenic";
  }

  if ($annotated)
\
