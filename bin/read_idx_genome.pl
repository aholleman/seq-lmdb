#!/usr/bin/env perl
# Name:           read_mongodb_genome.pl
# Description:    Annotates a given snpfile using binary indexed genome data generated by 'create_binary_genome_index.pl'.
#                 Input:  snpfile
#                 Output: tab-delim annotation, json annotation, tab-delim summary statistics for ids in snpfile,
#                         json summary statistics for ids in snpfile
#
# Date Created:   Tue Sep 21 13:36:45 2014
# Date Modified:  Tue Sep 21 13:26:45 2014
# By:             TS Wingo

use lib '/Users/twingo/software/Seq/lib';
use autodie;
use Cpanel::JSON::XS;
use File::Spec;
use IO::File;
use Getopt::Long;
use Modern::Perl qw(2013);
use Pod::Usage;
use Snpfile::Tools;
use YAML::XS qw( LoadFile );
use Seq::GenomeSizedTrackChar;
use DDP;

my $hg38_config_file = "/Users/twingo/software/Seq/t/hg38_build_test.yml";

my @exts              = qw(snp);
my @var_types         = qw(DEL INS SNP MESS);
my @var_type_codes    = qw(Silent Replacement Intronic Intergenic);
my @header_snpfile    = qw(Fragment Position Reference Minor_allele Type);
my @header_basefile   = qw(Fragment Position Reference);
my @header_annotation = qw(base raw_genome_dat
                           genomic_annotation_code
                           gene_annotation_code
                           alt_name transcript_id
                           org_codon aa snp_id maf);
my ($chr_wanted, $pos_from, $pos_to, $db_location, $yaml_config, $verbose);
my ($client, $db, $gan_db, $snp_db, $dbsnp_name, $dbgene_name);
my (%tracks);

#
# usage
#
die "usage --from <pos> --to <pos> --db_name <hg38> --l <.>"
  unless GetOptions(
                    'c|chr=s'      => \$chr_wanted,
                    'f|from=n'     => \$pos_from,
                    't|to=n'       => \$pos_to,
                    'c|config=s'   => \$yaml_config,
                    'l|location=s' => \$db_location,
                    'v|verbose'    => \$verbose,
                   )
  and defined $pos_from
  and defined $pos_to
  and defined $yaml_config
  and defined $db_location;

# clean up position
$pos_from =~ s/\_|\,//g;
$pos_to =~ s/\_|\,//g;

#
# sanity check position
#
if ($pos_from >= $pos_to)
{
  say "Error: from_position ('$pos_from') should be <= to_position ('$pos_to')\n";
  exit;
}


# load configuration file
my $config_data = LoadFile( $yaml_config );

# genome assembly
my $assembly //= $config_data->{genome_name};

# db location
$db_location = File::Spec->canonpath( $db_location );

# index directory
my $index_dir //= $config_data->{genome_index_dir};
$index_dir = File::Spec->canonpath( $index_dir );


#  make genome sized objects
for my $gst (@{ $config_data->{genome_sized_tracks} })
{
  # naming convetion is 'name.type.idx' and 'name.type.yml' for the index and
  # the chr_len offsets, respectively
  my $idx_file      = join( ".", $gst->{name}, $gst->{type}, 'idx' );
  my $yml_file      = join( ".", $gst->{name}, $gst->{type}, 'yml' );
  my $full_path_idx = File::Spec->catfile( $db_location, $index_dir, $idx_file );
  my $full_path_yml = File::Spec->catfile( $db_location, $index_dir, $yml_file );
  my $idx_fh        = new IO::File->new( $full_path_idx, 'r' )
    or die "cannot open $full_path_idx";

  binmode $idx_fh;
  my $gst_dat;
  read $idx_fh, $gst_dat, -s $full_path_idx;
  my $chr_len_href = LoadFile( $full_path_yml );

  my %gst_config = %$gst;
  $gst_config{genome_chrs}   = $config_data->{genome_chrs};
  $gst_config{genome_length} = -s $full_path_idx;
  $gst_config{chr_len}       = $chr_len_href;
  p %gst_config;
  $gst_config{char_seq}      = \$gst_dat;

  push @{ $tracks{$gst->{type}} }, Seq::GenomeSizedTrackChar->new( \%gst_config );
}

# my (%hg38_genome_config, %chr_lens);
#
# for my $attr_href ( @{ $config_data->{genome_sized_tracks} } )
# {
#   if ($attr_href->{type} eq "genome")
#   {
#     for my $attr ( keys %{ $attr_href })
#     {
#       $hg38_genome_config{ $attr } = $attr_href->{$attr};
#     }
#   }
# }
# $hg38_genome_config{genome_chrs}   = $hg38_dat->{genome_chrs};
# $hg38_genome_config{genome_length} =  -s $db_file;
# $hg38_genome_config{char_seq}      = \$genome_chr_seq;
# $hg38_genome_config{chr_len}       = $chr_len_href;
#
# my $gct = Seq::GenomeSizedTrackChar->new( \%hg38_genome_config );
my @seq;

for (my $i = $pos_from; $i < $pos_to; $i++)
{
  my $zero_idx = $i;
  my $one_idx  = $i + 1;

  my $genome = $tracks{genome}[0];

  my $base_code = $genome->get_base( $zero_idx  );
  my $chr = get_chr( $zero_idx  );
  my $rel_pos = $i + 1 - $genome->get_abs_pos( $chr, 1 );

  my $base = $genome->get_idx_base( $base_code );
  my $gan  = ($genome->get_idx_in_gan( $base_code )) ? 1 : 0;
  my $gene = ($genome->get_idx_in_gene( $base_code )) ? 1 : 0;
  my $exon = ($genome->get_idx_in_exon( $base_code )) ? 1 : 0;
  my $snp  = ($genome->get_idx_in_snp( $base_code )) ? 1 : 0;

  my @site_scores;
  for my $score_track ( @{ $tracks{score} } )
  {
    push @site_scores, $score_track->get_score( $zero_idx  );
  }

  say join ("\t", $i, $chr, $rel_pos, $base_code, $base, $gan, $gene, $exon, 
    $snp, @site_scores);
  push @seq, $base;
}

Print_fa (\@seq);

sub Print_fa {
  my $seq_aref = shift;

  for (my $i = 0; $i < @{ $seq_aref }; $i++)
  {
    print "\n" if ($i % 80 == 0);
    print $seq_aref->[$i];
  }
}

sub get_chr {
  my $pos = shift;
  my @chrs = @{ $config_data->{genome_chrs} };
  my $genome = $tracks{genome}[0];
  for my $i (0 .. scalar @chrs)
  {
    my $chr = $chrs[$i];
    my $chr_len = $genome->get_abs_pos( $chr, 1 );
    my $next_chr = $chrs[$i+1];
    my $next_chr_len = $genome->get_abs_pos( $next_chr, 1 );

    #say "$pos < $next_chr_len && $pos >= $chr_len";

    if ($pos < $next_chr_len && $pos >= $chr_len)
    {
      return $chr;
    }
  }
}


__END__

  #
  # read json files
  #
  {
    #
    # read chr lengths
    #
    my $json = Cpanel::JSON::XS->new();

    open(my $in_len, '<:raw', "$db_location/$db_name.len.json");
    local $/;
    my $json_len = <$in_len>;
    $chr_len_ref = decode_json($json_len);
    print $json->pretty(1)->encode($chr_len_ref);

    #
    # read typedefs and lengths
    #
    open(my $in_type, '<:raw', "$db_location/$db_name.type.json");
    my $json_type = <$in_type>;
    $bin_codes_ref = decode_json($json_type);
    print $json->pretty(1)->encode($bin_codes_ref);

    #
    # read idx codes
    #
    open (my $in_idx_codes, '<:raw', "$db_location/$db_name.idx_codes.json");
    my $json_idx_codes = <$in_idx_codes>;
    $idx_codes_ref = decode_json($json_idx_codes);
    print $json->pretty(1)->encode($idx_codes_ref);

    #
    # make hashes for
    #   1) base
    #   2) annoated
    #   3) in_gene
    #   4) exon
    #   5) snp
    #
    foreach my $base (sort keys %{ $idx_codes_ref })
    {
      foreach my $annotated (sort keys %{$idx_codes_ref->{$base}}) # do we lookup annotation
      {
        foreach my $in_gene (sort keys %{$idx_codes_ref->{$base}{$annotated}}) # intronic or exonic vs intergenic
        {
          foreach my $exon (sort keys %{$idx_codes_ref->{$base}{$annotated}{$in_gene}}) # intronic vs exonic
          {
            foreach my $snp (sort keys %{$idx_codes_ref->{$base}{$annotated}{$in_gene}{$exon}}) # do we lookup snp
            {
              my $code = $idx_codes_ref->{$base}{$annotated}{$in_gene}{$exon}{$snp};
              $idx_2_base{$code} = $base;
              if ($annotated)
              {
                $idx_2_annotated{$code} = $base;
              }
              if ($in_gene)
              {
                $idx_2_in_gene{$code} = $base;
              }
              if ($exon)
              {
                $idx_2_in_exon{$code} = $base;
              }
              if ($snp)
              {
                $idx_2_snp{$code} = $base;
              }
            }
          }
        }
      }
    }
  }
  #
  # exit if the chromosome that is wanted is not one of the chromosomes read
  #
  if (!exists($chr_len_ref->{$chr_wanted}))
  {
    say "the chromosome you supplied: $chr_wanted was not listed in the binary index";
  }
}

#
# read genome
#
{
  $bin_fhs{'idx'}->read($genome_dat_buffer, $chr_len_ref->{'genome'});
  say "finished reading genome";
}

for (my $i = $pos_from ; $i <= $pos_to ; $i++)
{
  my $json    = Cpanel::JSON::XS->new() if $verbose;
  my $abs_pos = $chr_len_ref->{$chr_wanted} + $i;
  my (%records, @gan_results, @snp_results, $gan_qres, $snp_qres) = ( );
  my ($base_code, $base, $annotated, $in_gene_code, $in_exon, $snp_code) = (0, 0, 0, 0, 0, 0);

  #
  # decode base
  #
  $base_code    = unpack($bin_codes_ref->{'typedef'}{'idx'}, (substr($genome_dat_buffer, ($abs_pos - 1), 1)));
  unless (defined $base_code) { die "$base_code - error extracing $chr_wanted:$i ($abs_pos) from genome - ensure you are within range";}
  $base         = $idx_2_base{$base_code}      if (exists($idx_2_base{$base_code}));
  $annotated    = $idx_2_annotated{$base_code} if (exists($idx_2_annotated{$base_code}));
  $in_gene_code = $idx_2_in_gene{$base_code}   if (exists($idx_2_in_gene{$base_code}));
  $in_exon      = $idx_2_in_exon{$base_code}   if (exists($idx_2_in_exon{$base_code}));
  $snp_code     = $idx_2_snp{$base_code}       if (exists($idx_2_snp{$base_code}));

  $records{'base'} = $base;
  $records{'raw_genome_dat'} = join("\t", $base_code, $base, $annotated, $in_gene_code, $in_exon, $snp_code);

  if ($in_gene_code)
  {
    if ($in_exon)
    {
      $records{'genomic_annotation_code'} = "Exonic";
    }
    else
    {
      $records{'genomic_annotation_code'} = "Introinc";
    }
  }
  else
  {
    $records{'genomic_annotation_code'} = "Intergenic";
  }

  if ($annotated)
\
